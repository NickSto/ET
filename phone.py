#!/usr/bin/env python3
import os
import sys
import ssl
import json
import errno
import string
import socket
import random
import logging
import http.client
import urllib.parse
import argparse
try:
  from utillib import version
except ImportError as error:
  sys.stderr.write(f'Error: Could not import utillib.version: {error}\n')
  version = None

SCRIPT_DIR = os.path.dirname(os.path.realpath(__file__))
if version is None:
  VERSION = '?'
else:
  VERSION_CONFIG = os.path.join(SCRIPT_DIR, 'VERSION')
  VERSION = str(version.get_version(repo_dir=SCRIPT_DIR, config_path=VERSION_CONFIG))
DEFAULT_DOMAIN = 'nstoler.com'
DEFAULT_TIMEOUT = 10  # seconds
DEFAULT_SECURE = True
API_PATH_TEMPLATE = '/ET/{}'
HEADERS = {
  'User-Agent':'ET-phone-home/'+VERSION,
  'Content-Type':'application/json; charset=utf-8'
}
ALPHABET_DEFAULT = string.ascii_letters + string.digits + '+/'
RUN_ID_LEN = 24


def make_argparser():
  parser = argparse.ArgumentParser()
  parser.add_argument('event_type', choices=('start', 'prelim', 'end'))
  parser.add_argument('-d', '--domain', default=DEFAULT_DOMAIN,
    help='Default: %(default)s')
  parser.add_argument('-p', '--project', default='ET',
    help='Default: %(default)s')
  parser.add_argument('-s', '--script', default=os.path.basename(os.path.realpath(__file__)),
    help='Default: %(default)s')
  parser.add_argument('-v', '--version', default=VERSION,
    help='Default: %(default)s')
  parser.add_argument('-P', '--platform',
    help='Default: %(default)s')
  parser.add_argument('-i', '--run-id', default=None,
    help='The run id generated by send_start().')
  parser.add_argument('-t', '--run-time', type=int,
    help='The run time, in seconds.')
  parser.add_argument('-r', '--run-data',
    help='Tool-specific data about the run, like input size, in JSON format.')
  parser.add_argument('-T', '--test', action='store_true', default=False,
    help='Mark this run as a test.')
  parser.add_argument('-S', '--secure', action='store_true', default=DEFAULT_SECURE,
    help='Enforce checking TLS certificates.')
  parser.add_argument('-I', '--insecure', dest='secure', action='store_false',
    help='Don\'t check TLS certificates.')
  parser.add_argument('-l', '--log', type=argparse.FileType('w'), default=sys.stderr,
    help='Print log messages to this file instead of to stderr. Warning: Will overwrite the file.')
  parser.add_argument('-q', '--quiet', dest='volume', action='store_const', const=logging.CRITICAL,
    default=logging.ERROR)
  parser.add_argument('-V', '--verbose', dest='volume', action='store_const', const=logging.INFO)
  parser.add_argument('-D', '--debug', dest='volume', action='store_const', const=logging.DEBUG)
  return parser


def main(argv):

  # If no other arguments are given, --version should just print the version of this script.
  if len(argv) == 2 and (argv[1] == '--version' or argv[1] == '-v'):
    print(VERSION)
    return 1

  parser = make_argparser()
  args = parser.parse_args(argv[1:])

  logging.basicConfig(stream=args.log, level=args.volume, format='%(message)s')
  tone_down_logger()

  call = Call(args.script,
              args,
              run_id=args.run_id,
              domain=args.domain,
              platform=args.platform,
              secure=args.secure,
              test=args.test)

  if args.run_data:
    try:
      run_data = json.loads(args.run_data)
    except ValueError:
      fail(f'Invalid --run-data. Must be valid JSON. Saw: {args.run_data!r}')
  else:
    run_data = {}

  if args.event_type == 'start':
    print(call.send_data(args.event_type))
  elif args.event_type == 'prelim':
    call.send_data(args.event_type, run_data=run_data)
  elif args.event_type == 'end':
    if not (args.run_id and args.run_time):
      fail('--run-id and --run-time and required for event_type "end".')
    call.send_data(args.event_type, run_data=run_data, run_time=args.run_time)
  else:
    fail(f'Unrecognized event type {args.event_type!r}.')


class Call(object):

  def __init__(self,
               script_path,
               version,
               run_id=None,
               domain=DEFAULT_DOMAIN,
               timeout=DEFAULT_TIMEOUT,
               secure=DEFAULT_SECURE,
               platform=None,
               test=False,
               fail='exception'):
    self.initialized = False
    try:
      if run_id is None:
        run_id = make_blob(RUN_ID_LEN)
      self.domain = domain
      self.timeout = timeout
      self.secure = secure
      self.fail = fail
      self.data = {
        'run_id': run_id,
        'project': version.project,
        'script': os.path.basename(script_path),
        'version': version.version,
        'test': test,
        'platform': platform
      }
      self.initialized = True
    except Exception as exception:
      if fail.startswith('except'):
        raise
      elif fail.startswith('warn'):
        logging.warn('Exception encountered in phone.Call.__init__():\n'+str(exception))
      elif fail == 'silent':
        pass

  def send_data(self, event_type, run_data={}, run_time=None):
    """Send data about an event to the logging server.
    The event_type must be one of the following:
    start: Note the invocation of the script.
      Required arguments: none.
    prelim: Send out some data before starting the script in earnest, in case it fails.
      For example, gather the filesizes of the inputs. Do this before the main part of the code,
      in case it throws an exception and we never get to "end".
      Required arguments: run_data.
    end: Report the end of the run and stats on the inputs.
      Required arguments: run_time."""
    try:
      if not self.initialized:
        raise Exception('Call object not initialized. Aborting send_data()..')
      # Validate inputs.
      if event_type == 'start':
        pass
      elif event_type == 'end':
        if run_time is None:
          raise Exception('run_time argument required for "end" event.')
      elif event_type == 'prelim':
        if not run_data:
          raise Exception('run_data argument required for "prelim" event.')
      else:
        raise ValueError(f'Invalid event type {event_type!r}.')
      # Assemble the data blob.
      data = self.construct_data(event_type, run_time, run_data)
      data_json = json.dumps(data)
      path = API_PATH_TEMPLATE.format(event_type)
      success = post_data(self.domain, path, data_json, secure=self.secure, timeout=self.timeout)
    except Exception as exception:
      if self.fail.startswith('except'):
        raise
      elif self.fail.startswith('warn'):
        logging.warn(f'Exception encountered in phone.send_{event_type}():\n{exception}')
      elif self.fail == 'silent':
        pass
      return None
    # Decide return value.
    if success:
      if event_type == 'start':
        return self.data['run_id']
      else:
        return True
    else:
      return False

  def construct_data(self, event_type, run_time=None, run_data={}):
    data = self.data.copy()
    if event_type == 'start':
      pass
    elif event_type == 'prelim':
      data['run'] = run_data
    elif event_type == 'end':
      data['run'] = {'time':run_time}
      data['run'].update(run_data)
    return data


def post_data(domain, path, data, secure=DEFAULT_SECURE, timeout=DEFAULT_TIMEOUT):
  if secure:
    conex = http.client.HTTPSConnection(domain, timeout=timeout)
  else:
    context = ssl._create_unverified_context()
    conex = http.client.HTTPSConnection(domain, context=context, timeout=timeout)
  logging.info(f'Sending to "https://{domain}{path}":\n{data}')
  try:
    conex.request('POST', path, data, HEADERS)
  except socket.gaierror:
    logging.error(f'Error requesting "https://{domain}{path}"')
    raise
  response = conex.getresponse()
  logging.info(f'HTTP response {response.status}')
  logging.info(response.read())
  if response.status != 200:
    fail(f'Sending data failed: HTTP response {response.status}.')
  else:
    return True


def split_url(url):
  # parse the URL's components
  scheme, domain, path, query_str, frag = urllib.parse.urlsplit(url)
  if path == '':
    path = '/'
  if query_str:
    path += '?'+query_str
  return scheme, domain, path


def make_blob(length, alphabet=ALPHABET_DEFAULT):
  chars = [random.choice(alphabet) for i in range(length)]
  return ''.join(chars)


def tone_down_logger():
  """Change the logging level names from all-caps to capitalized lowercase.
  E.g. "WARNING" -> "Warning" (turn down the volume a bit in your log files)"""
  for level in (logging.CRITICAL, logging.ERROR, logging.WARNING, logging.INFO, logging.DEBUG):
    level_name = logging.getLevelName(level)
    logging.addLevelName(level, level_name.capitalize())


def fail(message):
  logging.critical(message)
  if __name__ == '__main__':
    sys.exit(1)
  else:
    raise Exception(message)


if __name__ == '__main__':
  try:
    sys.exit(main(sys.argv))
  except IOError as ioe:
    if ioe.errno != errno.EPIPE:
      raise
